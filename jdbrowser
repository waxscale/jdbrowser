#!/home/jaguar/.pyenv/versions/jdbrowser/bin/python

import sys
import os
import configparser
import signal
import sqlite3
import uuid
import re
from PySide6 import QtCore, QtGui, QtWidgets

# Allow Ctrl+C (SIGINT) to quit the Qt application
signal.signal(signal.SIGINT, lambda sig, frame: QtWidgets.QApplication.quit())

# TokyoNight Dark theme colors
HIGHLIGHT_COLOR = '#44475a'
HOVER_COLOR = '#5c6370'
SLATE_COLOR = '#2e303e'
TEXT_COLOR = '#c0caf5'
BACKGROUND_COLOR = '#2e303e'
BORDER_COLOR = '#44475a'
BUTTON_COLOR = '#d7ba7d'

class EditTagDialog(QtWidgets.QDialog):
    def __init__(self, current_label, current_icon, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Edit Tag")
        self.setFixedWidth(300)
        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(10, 10, 10, 10)

        # Icon display (clickable)
        self.icon_label = QtWidgets.QLabel()
        self.icon_label.setMouseTracking(True)
        self.icon_label.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        self.new_icon_data = None  # Track new image data
        if current_icon:
            pixmap = QtGui.QPixmap()
            pixmap.loadFromData(current_icon)
            if not pixmap.isNull():
                rounded_pixmap = QtGui.QPixmap(240, 150)
                rounded_pixmap.fill(QtCore.Qt.transparent)
                painter = QtGui.QPainter(rounded_pixmap)
                painter.setRenderHint(QtGui.QPainter.Antialiasing)
                path = QtGui.QPainterPath()
                path.addRoundedRect(0, 0, 240, 150, 10, 10)
                painter.setClipPath(path)
                scaled_pixmap = pixmap.scaled(240, 150, QtCore.Qt.AspectRatioMode.KeepAspectRatio, QtCore.Qt.TransformationMode.SmoothTransformation)
                painter.drawPixmap(0, 0, scaled_pixmap)
                painter.end()
                self.icon_label.setPixmap(rounded_pixmap)
            else:
                self.icon_label = QtWidgets.QFrame()
                self.icon_label.setFixedSize(240, 150)
                self.icon_label.setStyleSheet(f'background-color: {SLATE_COLOR}; border-radius: 10px;')
        else:
            self.icon_label = QtWidgets.QFrame()
            self.icon_label.setFixedSize(240, 150)
            self.icon_label.setStyleSheet(f'background-color: {SLATE_COLOR}; border-radius: 10px;')
        self.icon_label.setMouseTracking(True)
        self.icon_label.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        self.icon_label.mousePressEvent = self.select_icon
        layout.addWidget(self.icon_label, alignment=QtCore.Qt.AlignmentFlag.AlignHCenter)

        # Label input
        self.label_input = QtWidgets.QLineEdit(current_label)
        self.label_input.setPlaceholderText("Enter tag label")
        self.label_input.setStyleSheet(f'''
            QLineEdit {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
                border: 1px solid {BORDER_COLOR};
                border-radius: 5px;
                padding: 5px;
            }}
        ''')
        layout.addWidget(self.label_input)

        # Buttons
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.setStyleSheet(f'''
            QPushButton {{
                background-color: {BUTTON_COLOR};
                color: black;
                border: none;
                padding: 5px;
                border-radius: 5px;
            }}
            QPushButton:hover {{
                background-color: #e0c58f;
            }}
        ''')
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        self.setStyleSheet(f'background-color: {BACKGROUND_COLOR};')

    def select_icon(self, event):
        """Open file dialog to select a new .png image and update the icon display."""
        file_dialog = QtWidgets.QFileDialog(self)
        file_dialog.setFileMode(QtWidgets.QFileDialog.ExistingFile)
        file_dialog.setNameFilter("Images (*.png)")
        file_dialog.setStyleSheet(f'''
            QFileDialog {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
            }}
            QLineEdit {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
                border: 1px solid {BORDER_COLOR};
                border-radius: 5px;
                padding: 5px;
            }}
            QPushButton {{
                background-color: {BUTTON_COLOR};
                color: black;
                border: none;
                padding: 5px;
                border-radius: 5px;
            }}
            QPushButton:hover {{
                background-color: #e0c58f;
            }}
            QToolButton {{
                background-color: {BUTTON_COLOR};
                color: black;
                border: none;
                padding: 5px;
                border-radius: 5px;
            }}
            QToolButton:hover {{
                background-color: #e0c58f;
            }}
            QLabel {{
                color: {TEXT_COLOR};
            }}
            QTreeView, QListView {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
                border: 1px solid {BORDER_COLOR};
            }}
            QTreeView::item:selected, QListView::item:selected {{
                background-color: {HIGHLIGHT_COLOR};
                color: {TEXT_COLOR};
            }}
            QTreeView::item:hover, QListView::item:hover {{
                background-color: {HOVER_COLOR};
            }}
            QComboBox {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
                border: 1px solid {BORDER_COLOR};
                border-radius: 5px;
                padding: 5px;
            }}
            QComboBox::drop-down {{
                border: none;
            }}
            QComboBox::down-arrow {{
                image: none;
            }}
            QComboBox QAbstractItemView {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
                selection-background-color: {HIGHLIGHT_COLOR};
            }}
        ''')
        if file_dialog.exec():
            file_path = file_dialog.selectedFiles()[0]
            pixmap = QtGui.QPixmap(file_path)
            if not pixmap.isNull():
                rounded_pixmap = QtGui.QPixmap(240, 150)
                rounded_pixmap.fill(QtCore.Qt.transparent)
                painter = QtGui.QPainter(rounded_pixmap)
                painter.setRenderHint(QtGui.QPainter.Antialiasing)
                path = QtGui.QPainterPath()
                path.addRoundedRect(0, 0, 240, 150, 10, 10)
                painter.setClipPath(path)
                scaled_pixmap = pixmap.scaled(240, 150, QtCore.Qt.AspectRatioMode.KeepAspectRatio, QtCore.Qt.TransformationMode.SmoothTransformation)
                painter.drawPixmap(0, 0, scaled_pixmap)
                painter.end()
                # Replace QFrame with QLabel if necessary
                if isinstance(self.icon_label, QtWidgets.QFrame):
                    layout = self.icon_label.parent().layout()
                    layout.removeWidget(self.icon_label)
                    self.icon_label.deleteLater()
                    self.icon_label = QtWidgets.QLabel()
                    self.icon_label.setFixedSize(240, 150)
                    self.icon_label.setMouseTracking(True)
                    self.icon_label.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
                    self.icon_label.mousePressEvent = self.select_icon
                    layout.insertWidget(0, self.icon_label, alignment=QtCore.Qt.AlignmentFlag.AlignHCenter)
                self.icon_label.setPixmap(rounded_pixmap)
                with open(file_path, 'rb') as f:
                    self.new_icon_data = f.read()

    def get_label(self):
        return self.label_input.text()

    def get_icon_data(self):
        return self.new_icon_data

class SimpleEditTagDialog(QtWidgets.QDialog):
    def __init__(self, current_label, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Rename Tag")
        self.setFixedWidth(300)
        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(10, 10, 10, 10)

        # Label input
        self.label_input = QtWidgets.QLineEdit(current_label)
        self.label_input.setPlaceholderText("Enter tag label")
        self.label_input.setStyleSheet(f'''
            QLineEdit {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
                border: 1px solid {BORDER_COLOR};
                border-radius: 5px;
                padding: 5px;
            }}
        ''')
        layout.addWidget(self.label_input)

        # Buttons
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.setStyleSheet(f'''
            QPushButton {{
                background-color: {BUTTON_COLOR};
                color: black;
                border: none;
                padding: 5px;
                border-radius: 5px;
            }}
            QPushButton:hover {{
                background-color: #e0c58f;
            }}
        ''')
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        self.setStyleSheet(f'background-color: {BACKGROUND_COLOR};')

    def get_label(self):
        return self.label_input.text()

class InputTagDialog(QtWidgets.QDialog):
    def __init__(self, default_jd_area, default_label, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Create Tag")
        self.setFixedWidth(300)
        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(10, 10, 10, 10)

        # jd_area input
        self.jd_area_input = QtWidgets.QLineEdit(str(default_jd_area))
        self.jd_area_input.setPlaceholderText("Enter jd_area (integer)")
        self.jd_area_input.setValidator(QtGui.QIntValidator())
        self.jd_area_input.setStyleSheet(f'''
            QLineEdit {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
                border: 1px solid {BORDER_COLOR};
                border-radius: 5px;
                padding: 5px;
            }}
        ''')
        layout.addWidget(QtWidgets.QLabel("jd_area:"))
        layout.addWidget(self.jd_area_input)

        # jd_id input (hidden for now)
        self.jd_id_input = QtWidgets.QLineEdit()
        self.jd_id_input.setPlaceholderText("Enter jd_id (integer, optional)")
        self.jd_id_input.setValidator(QtGui.QIntValidator())
        self.jd_id_input.setStyleSheet(f'''
            QLineEdit {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
                border: 1px solid {BORDER_COLOR};
                border-radius: 5px;
                padding: 5px;
            }}
        ''')
        # layout.addWidget(QtWidgets.QLabel("jd_id (optional):"))
        # layout.addWidget(self.jd_id_input)

        # jd_ext input (hidden for now)
        self.jd_ext_input = QtWidgets.QLineEdit()
        self.jd_ext_input.setPlaceholderText("Enter jd_ext (integer, optional)")
        self.jd_ext_input.setValidator(QtGui.QIntValidator())
        self.jd_ext_input.setStyleSheet(f'''
            QLineEdit {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
                border: 1px solid {BORDER_COLOR};
                border-radius: 5px;
                padding: 5px;
            }}
        ''')
        # layout.addWidget(QtWidgets.QLabel("jd_ext (optional):"))
        # layout.addWidget(self.jd_ext_input)

        # Label input
        self.label_input = QtWidgets.QLineEdit(default_label)
        self.label_input.setPlaceholderText("Enter tag label")
        self.label_input.setStyleSheet(f'''
            QLineEdit {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
                border: 1px solid {BORDER_COLOR};
                border-radius: 5px;
                padding: 5px;
            }}
        ''')
        layout.addWidget(QtWidgets.QLabel("Label:"))
        layout.addWidget(self.label_input)

        # Buttons
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.setStyleSheet(f'''
            QPushButton {{
                background-color: {BUTTON_COLOR};
                color: black;
                border: none;
                padding: 5px;
                border-radius: 5px;
            }}
            QPushButton:hover {{
                background-color: #e0c58f;
            }}
        ''')
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        # Style labels
        self.setStyleSheet(f'''
            QDialog {{
                background-color: {BACKGROUND_COLOR};
            }}
            QLabel {{
                color: {TEXT_COLOR};
            }}
        ''')

        # Focus the label input
        self.label_input.setFocus()

    def get_values(self):
        try:
            jd_area = int(self.jd_area_input.text()) if self.jd_area_input.text() else None
            jd_id = int(self.jd_id_input.text()) if self.jd_id_input.text() else None
            jd_ext = int(self.jd_ext_input.text()) if self.jd_ext_input.text() else None
        except ValueError:
            jd_area, jd_id, jd_ext = None, None, None
        return jd_area, jd_id, jd_ext, self.label_input.text()

class DeleteTagDialog(QtWidgets.QDialog):
    def __init__(self, tag_name, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Confirm Delete")
        self.setFixedWidth(600)  # User-specified width
        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(10, 10, 10, 10)

        # Confirmation message
        self.message = QtWidgets.QLabel(f"Are you sure you want to delete the tag '{tag_name}'?")
        self.message.setStyleSheet(f'color: {TEXT_COLOR};')
        layout.addWidget(self.message)

        # Buttons
        buttons = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)
        buttons.setStyleSheet(f'''
            QPushButton {{
                background-color: {BUTTON_COLOR};
                color: black;
                border: none;
                padding: 5px;
                border-radius: 5px;
            }}
            QPushButton:hover {{
                background-color: #e0c58f;
            }}
        ''')
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        self.setStyleSheet(f'background-color: {BACKGROUND_COLOR};')

class FileItem(QtWidgets.QWidget):
    def __init__(self, tag_id, name, jd_area, jd_id, jd_ext, icon_data, parent_path):
        super().__init__()
        self.tag_id = tag_id  # None for placeholder items
        self.name = name if name is not None else ""
        self.jd_area = jd_area
        self.jd_id = jd_id
        self.jd_ext = jd_ext
        self.isSelected = False
        self.isHover = False
        self.isDimmed = False
        self.setAttribute(QtCore.Qt.WidgetAttribute.WA_Hover)

        # Construct display label
        if self.jd_area is not None:
            if self.jd_id is None:
                prefix = f"[{self.jd_area:02d}]"
            elif self.jd_ext is None:
                prefix = f"[{self.jd_area:02d}.{self.jd_id:02d}]"
            else:
                prefix = f"[{self.jd_area:02d}.{self.jd_id:02d}+{self.jd_ext:04d}]"
            self.display_name = f"{prefix} {self.name}" if self.name else prefix
        else:
            self.display_name = self.name

        # Fix vertical size policy
        self.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)

        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(2)
        layout.setContentsMargins(2, 2, 2, 2)

        # Icon: Load from database BLOB or use slate placeholder
        if icon_data:
            pixmap = QtGui.QPixmap()
            pixmap.loadFromData(icon_data)
            if not pixmap.isNull():
                self.icon = QtWidgets.QLabel()
                rounded_pixmap = QtGui.QPixmap(240, 150)
                rounded_pixmap.fill(QtCore.Qt.transparent)
                painter = QtGui.QPainter(rounded_pixmap)
                painter.setRenderHint(QtGui.QPainter.Antialiasing)
                path = QtGui.QPainterPath()
                path.addRoundedRect(0, 0, 240, 150, 10, 10)
                painter.setClipPath(path)
                scaled_pixmap = pixmap.scaled(240, 150, QtCore.Qt.AspectRatioMode.KeepAspectRatio, QtCore.Qt.TransformationMode.SmoothTransformation)
                painter.drawPixmap(0, 0, scaled_pixmap)
                painter.end()
                self.icon.setPixmap(rounded_pixmap)
                self.icon.setFixedSize(240, 150)
                self.icon.setStyleSheet('background-color: transparent;')
            else:
                self.icon = QtWidgets.QFrame()
                self.icon.setFixedSize(240, 150)
                self.icon.setStyleSheet(f'background-color: {SLATE_COLOR}; border-radius: 10px;')
        else:
            self.icon = QtWidgets.QFrame()
            self.icon.setFixedSize(240, 150)
            self.icon.setStyleSheet(f'background-color: {SLATE_COLOR}; border-radius: 10px;')
        self.icon.setAutoFillBackground(True)
        layout.addWidget(self.icon, alignment=QtCore.Qt.AlignmentFlag.AlignHCenter)

        # Label (single line, empty for placeholders)
        self.label = QtWidgets.QLabel(self.display_name)
        self.label.setAlignment(QtCore.Qt.AlignmentFlag.AlignHCenter)
        self.label.setFixedWidth(240)
        self.label.setWordWrap(False)
        self.label.setStyleSheet(f'color: {TEXT_COLOR};')
        self.label.setAutoFillBackground(True)
        layout.addWidget(self.label, alignment=QtCore.Qt.AlignmentFlag.AlignHCenter)

        # Fixed height: icon + single line label + spacings and margins
        fm = self.label.fontMetrics()
        label_height = fm.height()
        spacing = layout.spacing()
        margins = layout.contentsMargins()
        total_height = 150 + label_height + spacing + margins.top() + margins.bottom()
        self.setFixedHeight(total_height)

        self.updateStyle()

    def updateStyle(self):
        # Prioritize isSelected over isHover for background
        if self.isSelected:
            bg = HIGHLIGHT_COLOR
        elif self.isHover:
            bg = HOVER_COLOR
        else:
            bg = 'transparent'
        # Apply dimming for non-matching items using QGraphicsOpacityEffect
        opacity = 0.4 if self.isDimmed else 1.0
        icon_effect = QtWidgets.QGraphicsOpacityEffect(self.icon)
        icon_effect.setOpacity(opacity)
        self.icon.setGraphicsEffect(icon_effect)
        label_effect = QtWidgets.QGraphicsOpacityEffect(self.label)
        label_effect.setOpacity(opacity)
        self.label.setGraphicsEffect(label_effect)
        icon_style = f'background-color: {SLATE_COLOR}; border-radius: 10px;' if isinstance(self.icon, QtWidgets.QFrame) else 'background-color: transparent;'
        self.setStyleSheet(f'background-color: {bg}; border-radius: 10px;')
        self.icon.setStyleSheet(icon_style)
        self.label.setStyleSheet(f'color: {TEXT_COLOR};')

    def enterEvent(self, event):
        self.isHover = True
        self.updateStyle()
        self.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        super().enterEvent(event)

    def leaveEvent(self, event):
        self.isHover = False
        self.updateStyle()
        self.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.ArrowCursor))
        super().leaveEvent(event)

    def mousePressEvent(self, event):
        """Select this item when clicked, including placeholders."""
        if event.button() == QtCore.Qt.LeftButton:
            parent = self
            while not isinstance(parent, FileBrowser):
                parent = parent.parent()
                if parent is None:
                    return
            # Find this item in sections
            for s, sec in enumerate(parent.sections):
                for i, item in enumerate(sec):
                    if item == self:
                        parent.sec_idx = s
                        parent.idx_in_sec = i
                        parent.updateSelection()
                        break
        super().mousePressEvent(event)

class SearchLineEdit(QtWidgets.QLineEdit):
    def __init__(self, parent):
        super().__init__(parent)
        self.parent_browser = parent
        self.setStyleSheet(f'''
            QLineEdit {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
                border: 1px solid {BORDER_COLOR};
                border-radius: 5px;
                padding: 5px;
                font-family: 'FiraCode Nerd Font';
            }}
        ''')

    def focusOutEvent(self, event):
        # Exit search mode like Enter when losing focus
        self.parent_browser.exit_search_mode_select()
        super().focusOutEvent(event)

class FileBrowser(QtWidgets.QMainWindow):
    def __init__(self, directory):
        super().__init__()
        self.directory = directory
        self.setWindowTitle(f"File Browser - {self.directory}")
        self.cols = 5
        self.sections = []
        self.section_jd_areas = []  # Store base jd_area for each section
        self.section_filenames = []  # Store .2do filenames for sorting
        self.sec_idx = 0
        self.idx_in_sec = 0
        self.desired_col = 0
        self.in_search_mode = False
        self.prev_sec_idx = 0
        self.prev_idx_in_sec = 0
        self.search_matches = []
        self.current_match_idx = -1
        self.shortcuts = []
        self.search_shortcut_instances = []
        # Load show_hidden state from QSettings
        settings = QtCore.QSettings("xAI", "jdbrowser")
        self.show_hidden = settings.value("show_hidden", False, type=bool)

        # Initialize SQLite database
        xdg_data_home = os.getenv('XDG_DATA_HOME', os.path.expanduser('~/.local/share'))
        db_dir = os.path.join(xdg_data_home, 'jdbrowser')
        os.makedirs(db_dir, exist_ok=True)
        self.db_path = os.path.join(db_dir, 'tag.db')
        self.conn = sqlite3.connect(self.db_path)
        self.conn.execute('PRAGMA foreign_keys = ON')
        self._setup_database()

        # Disable window decorations
        self.setWindowFlags(QtCore.Qt.FramelessWindowHint)

        self._setup_ui()
        self._setup_shortcuts()
        self.updateSelection()

        # Restore saved position and size
        if settings.contains("pos") and settings.contains("size"):
            self.move(settings.value("pos", type=QtCore.QPoint))
            self.resize(settings.value("size", type=QtCore.QSize))

    def _setup_database(self):
        """Initialize SQLite database tables with unique constraint and triggers."""
        cursor = self.conn.cursor()
        cursor.executescript("""
            PRAGMA foreign_keys = ON;

            CREATE TABLE IF NOT EXISTS events (
                event_id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_type TEXT NOT NULL CHECK (
                    event_type IN (
                        'create_tag',
                        'set_tag_path',
                        'set_tag_label',
                        'set_tag_icon',
                        'delete_tag'
                    )
                ),
                timestamp TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now'))
            );

            CREATE TABLE IF NOT EXISTS event_create_tag (
                event_id INTEGER PRIMARY KEY,
                tag_id TEXT NOT NULL,
                FOREIGN KEY (event_id) REFERENCES events(event_id) ON DELETE CASCADE
            );

            CREATE TABLE IF NOT EXISTS event_set_tag_path (
                event_id INTEGER PRIMARY KEY,
                tag_id TEXT NOT NULL,
                jd_area INTEGER,
                jd_id INTEGER,
                jd_ext INTEGER,
                FOREIGN KEY (event_id) REFERENCES events(event_id) ON DELETE CASCADE,
                UNIQUE(jd_area, jd_id, jd_ext)
            );

            CREATE TABLE IF NOT EXISTS event_set_tag_label (
                event_id INTEGER PRIMARY KEY,
                tag_id TEXT NOT NULL,
                new_label TEXT NOT NULL,
                FOREIGN KEY (event_id) REFERENCES events(event_id) ON DELETE CASCADE
            );

            CREATE TABLE IF NOT EXISTS event_set_tag_icon (
                event_id INTEGER PRIMARY KEY,
                tag_id TEXT NOT NULL,
                icon BLOB,
                FOREIGN KEY (event_id) REFERENCES events(event_id) ON DELETE CASCADE
            );

            CREATE TABLE IF NOT EXISTS event_delete_tag (
                event_id INTEGER PRIMARY KEY,
                tag_id TEXT NOT NULL,
                FOREIGN KEY (event_id) REFERENCES events(event_id) ON DELETE CASCADE
            );

            CREATE TABLE IF NOT EXISTS state_tag_icons (
                tag_id TEXT PRIMARY KEY,
                icon BLOB
            );

            CREATE TABLE IF NOT EXISTS state_tags (
                tag_id TEXT PRIMARY KEY,
                jd_area INTEGER,
                jd_id INTEGER,
                jd_ext INTEGER,
                label TEXT NOT NULL,
                UNIQUE(jd_area, jd_id, jd_ext)
            );

            -- Trigger to prevent jd_id without jd_area
            CREATE TRIGGER IF NOT EXISTS check_jd_id
            BEFORE INSERT ON event_set_tag_path
            WHEN NEW.jd_id IS NOT NULL AND NEW.jd_area IS NULL
            BEGIN
                SELECT RAISE(ABORT, 'jd_id requires jd_area');
            END;

            -- Trigger to prevent jd_ext without jd_id
            CREATE TRIGGER IF NOT EXISTS check_jd_ext
            BEFORE INSERT ON event_set_tag_path
            WHEN NEW.jd_ext IS NOT NULL AND NEW.jd_id IS NULL
            BEGIN
                SELECT RAISE(ABORT, 'jd_ext requires jd_id');
            END;
        """)
        self._rebuild_state_tags()
        self.conn.commit()

    def _rebuild_state_tags(self):
        """Rebuild the state_tags table from the event log."""
        cursor = self.conn.cursor()
        cursor.executescript("""
            DELETE FROM state_tags;

            INSERT INTO state_tags (tag_id, jd_area, jd_id, jd_ext, label)
            SELECT
                p.tag_id,
                p.jd_area,
                p.jd_id,
                p.jd_ext,
                l.new_label
            FROM (
                SELECT
                    p.tag_id,
                    p.jd_area,
                    p.jd_id,
                    p.jd_ext,
                    p.event_id
                FROM event_set_tag_path p
                JOIN (
                    SELECT tag_id, MAX(event_id) AS max_event
                    FROM event_set_tag_path
                    GROUP BY tag_id
                ) latest_path ON p.tag_id = latest_path.tag_id AND p.event_id = latest_path.max_event
            ) p
            JOIN (
                SELECT
                    l.tag_id,
                    l.new_label,
                    l.event_id
                FROM event_set_tag_label l
                JOIN (
                    SELECT tag_id, MAX(event_id) AS max_event
                    FROM event_set_tag_label
                    GROUP BY tag_id
                ) latest_label ON l.tag_id = latest_label.tag_id AND l.event_id = latest_label.max_event
            ) l ON p.tag_id = l.tag_id
            WHERE p.tag_id NOT IN (SELECT tag_id FROM event_delete_tag);
        """)
        cursor.executescript("""
            DELETE FROM state_tag_icons;

            INSERT INTO state_tag_icons (tag_id, icon)
            SELECT
                i.tag_id,
                i.icon
            FROM event_set_tag_icon i
            JOIN (
                SELECT tag_id, MAX(event_id) AS max_event
                FROM event_set_tag_icon
                GROUP BY tag_id
            ) latest ON i.tag_id = latest.tag_id AND i.event_id = latest.max_event
            WHERE i.tag_id NOT IN (SELECT tag_id FROM event_delete_tag);
        """)
        self.conn.commit()

    def _is_hidden_item(self, name):
        """Check if an item should be hidden based on naming patterns."""
        if self.show_hidden:
            return False
        hidden_patterns = [
            '[00].png', '[00] #auto.png',
            '[.00].png', '[.00] #auto.png',
            '[+0000].png', '[+0000] #auto.png',
            '[0-META 0000-00-00 00.00.00].png', '[0-META 0000-00-00 00.00.00] #auto.png'
        ]
        return name.startswith('.') or name in hidden_patterns

    def _create_tag(self, jd_area, jd_id, jd_ext, label):
        """Create a new tag and return its tag_id, or None if constraints are violated."""
        cursor = self.conn.cursor()
        # Check for unique (jd_area, jd_id, jd_ext) constraint
        cursor.execute("SELECT tag_id FROM state_tags WHERE jd_area IS ? AND jd_id IS ? AND jd_ext IS ?", (jd_area, jd_id, jd_ext))
        if cursor.fetchone():
            return None  # Conflict exists
        # Validate constraints: no jd_id without jd_area, no jd_ext without jd_id
        if jd_id is not None and jd_area is None:
            return None
        if jd_ext is not None and jd_id is None:
            return None
        tag_id = str(uuid.uuid4())
        cursor.execute("INSERT INTO events (event_type) VALUES ('create_tag')")
        event_id = cursor.lastrowid
        cursor.execute("INSERT INTO event_create_tag (event_id, tag_id) VALUES (?, ?)", (event_id, tag_id))
        cursor.execute("INSERT INTO events (event_type) VALUES ('set_tag_path')")
        event_id = cursor.lastrowid
        cursor.execute("INSERT INTO event_set_tag_path (event_id, tag_id, jd_area, jd_id, jd_ext) VALUES (?, ?, ?, ?, ?)", (event_id, tag_id, jd_area, jd_id, jd_ext))
        cursor.execute("INSERT INTO events (event_type) VALUES ('set_tag_label')")
        event_id = cursor.lastrowid
        cursor.execute("INSERT INTO event_set_tag_label (event_id, tag_id, new_label) VALUES (?, ?, ?)", (event_id, tag_id, label))
        self.conn.commit()
        return tag_id

    def _set_thumbnail(self):
        """Open a file dialog to select a .png image and set it as the thumbnail for the current tag."""
        if not self.sections or self.sec_idx >= len(self.sections) or self.idx_in_sec >= len(self.sections[self.sec_idx]):
            return
        current_item = self.sections[self.sec_idx][self.idx_in_sec]
        if not current_item.tag_id:  # Skip placeholder items
            return
        tag_id = current_item.tag_id
        file_dialog = QtWidgets.QFileDialog(self)
        file_dialog.setFileMode(QtWidgets.QFileDialog.ExistingFile)
        file_dialog.setNameFilter("Images (*.png)")
        file_dialog.setStyleSheet(f'''
            QFileDialog {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
            }}
            QLineEdit {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
                border: 1px solid {BORDER_COLOR};
                border-radius: 5px;
                padding: 5px;
            }}
            QPushButton {{
                background-color: {BUTTON_COLOR};
                color: black;
                border: none;
                padding: 5px;
                border-radius: 5px;
            }}
            QPushButton:hover {{
                background-color: #e0c58f;
            }}
            QToolButton {{
                background-color: {BUTTON_COLOR};
                color: black;
                border: none;
                padding: 5px;
                border-radius: 5px;
            }}
            QToolButton:hover {{
                background-color: #e0c58f;
            }}
            QLabel {{
                color: {TEXT_COLOR};
            }}
            QTreeView, QListView {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
                border: 1px solid {BORDER_COLOR};
            }}
            QTreeView::item:selected, QListView::item:selected {{
                background-color: {HIGHLIGHT_COLOR};
                color: {TEXT_COLOR};
            }}
            QTreeView::item:hover, QListView::item:hover {{
                background-color: {HOVER_COLOR};
            }}
            QComboBox {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
                border: 1px solid {BORDER_COLOR};
                border-radius: 5px;
                padding: 5px;
            }}
            QComboBox::drop-down {{
                border: none;
            }}
            QComboBox::down-arrow {{
                image: none;
            }}
            QComboBox QAbstractItemView {{
                background-color: {BACKGROUND_COLOR};
                color: {TEXT_COLOR};
                selection-background-color: {HIGHLIGHT_COLOR};
            }}
        ''')
        if file_dialog.exec():
            file_path = file_dialog.selectedFiles()[0]
            pixmap = QtGui.QPixmap(file_path)
            if not pixmap.isNull():
                with open(file_path, 'rb') as f:
                    icon_data = f.read()
                cursor = self.conn.cursor()
                cursor.execute("INSERT INTO events (event_type) VALUES ('set_tag_icon')")
                event_id = cursor.lastrowid
                cursor.execute("INSERT INTO event_set_tag_icon (event_id, tag_id, icon) VALUES (?, ?, ?)", (event_id, tag_id, icon_data))
                self.conn.commit()
                self._rebuild_state_tags()
                self._rebuild_ui()

    def _append_tag_to_section(self):
        """Append a tag to the current section with jd_area = max + 1 or section base."""
        if not self.sections or self.sec_idx >= len(self.sections):
            return
        cursor = self.conn.cursor()
        jd_area = self.section_jd_areas[self.sec_idx]
        cursor.execute("SELECT MAX(jd_area) FROM state_tags WHERE jd_area >= ? AND jd_area < ?", (jd_area, jd_area + 10))
        max_jd_area = cursor.fetchone()[0]
        new_jd_area = max_jd_area + 1 if max_jd_area is not None else jd_area
        label = "NewTag"
        new_tag_id = self._create_tag(new_jd_area, None, None, label)
        if new_tag_id:  # Only rebuild if tag was created successfully
            self._rebuild_state_tags()
            self._rebuild_ui(new_tag_id=new_tag_id)

    def _input_tag_dialog(self):
        """Open a dialog to input jd_area, jd_id, jd_ext, and label for a new tag."""
        if not self.sections or self.sec_idx >= len(self.sections):
            return
        cursor = self.conn.cursor()
        jd_area = self.section_jd_areas[self.sec_idx]
        cursor.execute("SELECT MAX(jd_area) FROM state_tags WHERE jd_area >= ? AND jd_area < ?", (jd_area, jd_area + 10))
        max_jd_area = cursor.fetchone()[0]
        default_jd_area = max_jd_area + 1 if max_jd_area is not None else jd_area
        default_label = "NewTag"
        while True:
            dialog = InputTagDialog(default_jd_area, default_label, self)
            if dialog.exec() == QtWidgets.QDialog.Accepted:
                jd_area, jd_id, jd_ext, label = dialog.get_values()
                if jd_area is None:
                    QtWidgets.QMessageBox.warning(self, "Invalid Input", "jd_area must be an integer.")
                    continue
                if jd_id is not None and jd_area is None:
                    QtWidgets.QMessageBox.warning(self, "Invalid Input", "jd_id requires jd_area.")
                    continue
                if jd_ext is not None and jd_id is None:
                    QtWidgets.QMessageBox.warning(self, "Invalid Input", "jd_ext requires jd_id.")
                    continue
                if not label:
                    QtWidgets.QMessageBox.warning(self, "Invalid Input", "Label cannot be empty.")
                    continue
                new_tag_id = self._create_tag(jd_area, jd_id, jd_ext, label)
                if new_tag_id:
                    self._rebuild_state_tags()
                    self._rebuild_ui(new_tag_id=new_tag_id)
                    break
                else:
                    QtWidgets.QMessageBox.warning(self, "Constraint Violation", f"The combination (jd_area={jd_area}, jd_id={jd_id}, jd_ext={jd_ext}) is already in use.")
            else:
                break

    def _edit_tag_label_with_icon(self):
        """Edit the current tag's label and thumbnail with a dialog showing the icon."""
        if not self.sections or self.sec_idx >= len(self.sections) or self.idx_in_sec >= len(self.sections[self.sec_idx]):
            return
        current_item = self.sections[self.sec_idx][self.idx_in_sec]
        if not current_item.tag_id:  # Skip placeholder items
            return
        tag_id = current_item.tag_id
        cursor = self.conn.cursor()
        cursor.execute("SELECT label FROM state_tags WHERE tag_id = ?", (tag_id,))
        current_label = cursor.fetchone()[0]
        cursor.execute("SELECT icon FROM state_tag_icons WHERE tag_id = ?", (tag_id,))
        icon_data = cursor.fetchone()
        icon_data = icon_data[0] if icon_data else None
        dialog = EditTagDialog(current_label, icon_data, self)
        if dialog.exec() == QtWidgets.QDialog.Accepted:
            new_label = dialog.get_label()
            new_icon_data = dialog.get_icon_data()
            if new_label:
                cursor.execute("INSERT INTO events (event_type) VALUES ('set_tag_label')")
                event_id = cursor.lastrowid
                cursor.execute("INSERT INTO event_set_tag_label (event_id, tag_id, new_label) VALUES (?, ?, ?)", (event_id, tag_id, new_label))
            if new_icon_data:
                cursor.execute("INSERT INTO events (event_type) VALUES ('set_tag_icon')")
                event_id = cursor.lastrowid
                cursor.execute("INSERT INTO event_set_tag_icon (event_id, tag_id, icon) VALUES (?, ?, ?)", (event_id, tag_id, new_icon_data))
            self.conn.commit()
            self._rebuild_state_tags()
            self._rebuild_ui()

    def _rename_tag_label(self):
        """Edit the current tag's label with a simple dialog."""
        if not self.sections or self.sec_idx >= len(self.sections) or self.idx_in_sec >= len(self.sections[self.sec_idx]):
            return
        current_item = self.sections[self.sec_idx][self.idx_in_sec]
        if not current_item.tag_id:  # Skip placeholder items
            return
        tag_id = current_item.tag_id
        cursor = self.conn.cursor()
        cursor.execute("SELECT label FROM state_tags WHERE tag_id = ?", (tag_id,))
        current_label = cursor.fetchone()[0]
        dialog = SimpleEditTagDialog(current_label, self)
        if dialog.exec() == QtWidgets.QDialog.Accepted:
            new_label = dialog.get_label()
            if new_label:
                cursor.execute("INSERT INTO events (event_type) VALUES ('set_tag_label')")
                event_id = cursor.lastrowid
                cursor.execute("INSERT INTO event_set_tag_label (event_id, tag_id, new_label) VALUES (?, ?, ?)", (event_id, tag_id, new_label))
                self.conn.commit()
                self._rebuild_state_tags()
                self._rebuild_ui()

    def _delete_tag(self):
        """Delete the current tag with a confirmation dialog."""
        if not self.sections or self.sec_idx >= len(self.sections) or self.idx_in_sec >= len(self.sections[self.sec_idx]):
            return
        current_item = self.sections[self.sec_idx][self.idx_in_sec]
        if not current_item.tag_id:  # Skip placeholder items
            return
        tag_id = current_item.tag_id
        cursor = self.conn.cursor()
        cursor.execute("SELECT label, jd_area, jd_id, jd_ext FROM state_tags WHERE tag_id = ?", (tag_id,))
        tag_name, jd_area, jd_id, jd_ext = cursor.fetchone()
        # Construct display name for dialog
        if jd_area is not None:
            if jd_id is None:
                prefix = f"[{jd_area:02d}]"
            elif jd_ext is None:
                prefix = f"[{jd_area:02d}.{jd_id:02d}]"
            else:
                prefix = f"[{jd_area:02d}.{jd_id:02d}+{jd_ext:04d}]"
            display_name = f"{prefix} {tag_name}" if tag_name else prefix
        else:
            display_name = tag_name
        dialog = DeleteTagDialog(display_name, self)
        if dialog.exec() == QtWidgets.QDialog.Accepted:
            cursor.execute("INSERT INTO events (event_type) VALUES ('delete_tag')")
            event_id = cursor.lastrowid
            cursor.execute("INSERT INTO event_delete_tag (event_id, tag_id) VALUES (?, ?)", (event_id, tag_id))
            self.conn.commit()
            self._rebuild_state_tags()
            # Adjust selection to the previous item
            if self.idx_in_sec > 0:
                self.idx_in_sec -= 1
            elif self.sec_idx > 0:
                self.sec_idx -= 1
                self.idx_in_sec = len(self.sections[self.sec_idx]) - 1
            else:
                self.sec_idx = 0
                self.idx_in_sec = 0
            self._rebuild_ui()

    def _setup_search_shortcuts(self):
        """Set up search mode shortcuts for the current search_input widget."""
        for shortcut in self.search_shortcut_instances:
            shortcut.deleteLater()
        self.search_shortcut_instances = []
        search_shortcuts = [
            (QtCore.Qt.Key_Escape, self.exit_search_mode_revert, None),
            (QtCore.Qt.Key_BracketLeft, self.exit_search_mode_revert, None, QtCore.Qt.KeyboardModifier.ControlModifier),
            (QtCore.Qt.Key_Return, self.exit_search_mode_select, None),
            (QtCore.Qt.Key_G, self.next_match, None, QtCore.Qt.KeyboardModifier.ControlModifier),
            (QtCore.Qt.Key_G, self.prev_match, None, QtCore.Qt.KeyboardModifier.ControlModifier | QtCore.Qt.KeyboardModifier.ShiftModifier),
            (QtCore.Qt.Key_N, self.next_match, None, QtCore.Qt.KeyboardModifier.ControlModifier),
            (QtCore.Qt.Key_P, self.prev_match, None, QtCore.Qt.KeyboardModifier.ControlModifier),
        ]
        for mapping in search_shortcuts:
            key, func, arg = mapping[0], mapping[1], mapping[2]
            modifiers = mapping[3] if len(mapping) > 3 else QtCore.Qt.KeyboardModifier.NoModifier
            s = QtGui.QShortcut(QtGui.QKeySequence(key | modifiers), self.search_input)
            s.setEnabled(False)
            if arg is None:
                s.activated.connect(func)
            else:
                s.activated.connect(lambda f=func, a=arg: f(a))
            self.search_shortcut_instances.append(s)

    def _setup_ui(self):
        self.scroll = QtWidgets.QScrollArea()
        self.scroll.setWidgetResizable(True)
        container = QtWidgets.QWidget()
        mainLayout = QtWidgets.QVBoxLayout(container)
        mainLayout.setSpacing(10)
        mainLayout.setContentsMargins(5, 5, 5, 5)

        self.sections = []
        self.section_jd_areas = []
        self.section_filenames = []
        current_section = []
        col = 0

        # Read headers from disk, sort alphabetically
        entries = sorted(os.listdir(self.directory), key=lambda x: x.lower())
        cursor = self.conn.cursor()
        cursor.execute("SELECT tag_id, jd_area, jd_id, jd_ext, label FROM state_tags ORDER BY jd_area, jd_id, jd_ext")
        tags = cursor.fetchall()
        tag_dict = {tag[0]: (tag[1], tag[2], tag[3], tag[4]) for tag in tags}
        cursor.execute("SELECT tag_id, icon FROM state_tag_icons")
        icons = {row[0]: row[1] for row in cursor.fetchall()}

        # Extract numerical prefixes from .2do filenames for section assignment
        section_prefixes = []
        for name in entries:
            if self._is_hidden_item(name) or not name.lower().endswith('.2do'):
                continue
            header_text = os.path.splitext(name)[0]
            match = re.match(r"\[(\d+)[^\]]*\]", header_text)
            prefix = int(match.group(1)) if match else 0
            section_prefixes.append((name, prefix))

        # Assign tags to sections based on alphabetical order of .2do filenames
        tags_by_section = {}
        for tag_id, (jd_area, jd_id, jd_ext, label) in tag_dict.items():
            # Find the .2do file with the largest prefix <= jd_area
            section_name = None
            if jd_area is not None:
                for name, prefix in sorted(section_prefixes, key=lambda x: x[0].lower()):
                    if prefix <= jd_area:
                        section_name = name
                    else:
                        break
            if section_name:
                tags_by_section.setdefault(section_name, []).append((tag_id, jd_area, jd_id, jd_ext, label))
            else:
                # If no prefix matches or jd_area is NULL, assign to the first section
                tags_by_section.setdefault(section_prefixes[0][0], []).append((tag_id, jd_area, jd_id, jd_ext, label))

        # Build UI sections
        section_index = 0
        for name in entries:
            if self._is_hidden_item(name):
                continue
            if name.lower().endswith('.2do'):
                # Flush current section
                if current_section:
                    sectionWidget = QtWidgets.QWidget()
                    sectionLayout = QtWidgets.QVBoxLayout(sectionWidget)
                    sectionLayout.setSpacing(5)
                    sectionLayout.setContentsMargins(0, 0, 0, 0)
                    sectionLayout.setAlignment(QtCore.Qt.AlignmentFlag.AlignLeft)
                    rowLayout = None
                    for i, item in enumerate(current_section):
                        if i % self.cols == 0:
                            if rowLayout:
                                sectionLayout.addLayout(rowLayout)
                            rowLayout = QtWidgets.QHBoxLayout()
                            rowLayout.setSpacing(5)
                            rowLayout.setContentsMargins(0, 0, 0, 0)
                            rowLayout.setAlignment(QtCore.Qt.AlignmentFlag.AlignLeft)
                        rowLayout.addWidget(item)
                    if rowLayout:
                        sectionLayout.addLayout(rowLayout)
                    sectionWidget.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
                    mainLayout.addWidget(sectionWidget)
                    mainLayout.setAlignment(sectionWidget, QtCore.Qt.AlignmentFlag.AlignLeft)
                    self.sections.append(current_section)
                # Header
                header_text = os.path.splitext(name)[0]
                header = QtWidgets.QLabel(header_text)
                header.setAlignment(QtCore.Qt.AlignmentFlag.AlignLeft | QtCore.Qt.AlignmentFlag.AlignVCenter)
                font = header.font()
                font.setPointSize(int(font.pointSize() * 1.5))
                font.setBold(True)
                header.setFont(font)
                header.setStyleSheet(f'background-color: {BUTTON_COLOR}; color: black; padding-left:5px; padding-right:5px;')
                header.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
                header.setMinimumWidth(self.scroll.viewport().width() - 10)
                fm = header.fontMetrics()
                header.setFixedHeight(fm.height() + 6)
                mainLayout.addWidget(header)
                mainLayout.addSpacing(10)
                # Determine jd_area from filename or section index (0 for first section)
                match = re.match(r"\[(\d+)[^\]]*\]", header_text)
                jd_area = int(match.group(1)) if match else section_index * 10
                if section_index == 0:
                    jd_area = 0
                # Create a section with tags or a placeholder
                current_section = []
                if name in tags_by_section:
                    # Sort tags by full constructed label
                    def get_sort_key(tag):
                        jd_area, jd_id, jd_ext, label = tag[1:5]
                        if jd_area is not None:
                            if jd_id is None:
                                prefix = f"[{jd_area:02d}]"
                            elif jd_ext is None:
                                prefix = f"[{jd_area:02d}.{jd_id:02d}]"
                            else:
                                prefix = f"[{jd_area:02d}.{jd_id:02d}+{jd_ext:04d}]"
                            return f"{prefix} {label}" if label else prefix
                        return label or ""
                    for tag_id, tag_jd_area, tag_jd_id, tag_jd_ext, label in sorted(tags_by_section[name], key=get_sort_key):
                        icon_data = icons.get(tag_id)
                        item = FileItem(tag_id, label, tag_jd_area, tag_jd_id, tag_jd_ext, icon_data, self.directory)
                        current_section.append(item)
                        col += 1
                else:
                    current_section.append(FileItem(None, None, None, None, None, None, self.directory))
                self.section_jd_areas.append(jd_area)
                self.section_filenames.append(name)
                section_index += 1
                col = 0
                continue

        # Flush last section
        if current_section:
            sectionWidget = QtWidgets.QWidget()
            sectionLayout = QtWidgets.QVBoxLayout(sectionWidget)
            sectionLayout.setSpacing(5)
            sectionLayout.setContentsMargins(0, 0, 0, 0)
            sectionLayout.setAlignment(QtCore.Qt.AlignmentFlag.AlignLeft)
            rowLayout = None
            for i, item in enumerate(current_section):
                if i % self.cols == 0:
                    if rowLayout:
                        sectionLayout.addLayout(rowLayout)
                    rowLayout = QtWidgets.QHBoxLayout()
                    rowLayout.setSpacing(5)
                    rowLayout.setContentsMargins(0, 0, 0, 0)
                    rowLayout.setAlignment(QtCore.Qt.AlignmentFlag.AlignLeft)
                rowLayout.addWidget(item)
            if rowLayout:
                sectionLayout.addLayout(rowLayout)
            sectionWidget.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
            mainLayout.addWidget(sectionWidget)
            mainLayout.setAlignment(sectionWidget, QtCore.Qt.AlignmentFlag.AlignLeft)
            self.sections.append(current_section)

        mainLayout.addStretch()
        container.setStyleSheet(f'background-color: #000000;')
        container.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        self.scroll.setWidget(container)
        self.setCentralWidget(self.scroll)

        # Search input box
        self.search_input = SearchLineEdit(self)
        self.search_input.setFixedWidth(300)
        self.search_input.setFixedHeight(30)
        self.search_input.hide()
        self.search_input.textChanged.connect(self.perform_search)

        self._setup_search_shortcuts()
        self.search_input.move(self.width() - 310, self.height() - 40)

        style = f'''
        * {{ font-family: 'FiraCode Nerd Font'; }}
        QWidget {{ background-color: #000000; }}
        QMainWindow {{ background-color: #000000; }}
        QScrollArea {{ border: none; background-color: #000000; }}
        QScrollBar:vertical {{
            width: 8px;
            background: #000000;
        }}
        QScrollBar::handle:vertical {{
            background: {BORDER_COLOR};
            min-height: 20px;
            border-radius: 4px;
        }}
        QScrollBar::add-line, QScrollBar::sub-line {{ height: 0; }}
        QScrollBar::add-page, QScrollBar::sub-page {{ background: none; }}
        '''
        self.setStyleSheet(style)

    def _rebuild_ui(self, new_tag_id=None):
        """Rebuild the UI to reflect the current state, selecting new_tag_id or current_tag_id."""
        current_tag_id = None
        if self.sections and 0 <= self.sec_idx < len(self.sections) and 0 <= self.idx_in_sec < len(self.sections[self.sec_idx]):
            current_tag_id = self.sections[self.sec_idx][self.idx_in_sec].tag_id
        old_widget = self.scroll.takeWidget()
        if old_widget:
            old_widget.deleteLater()
        self.sections = []
        self.section_jd_areas = []
        self.section_filenames = []
        self._setup_ui()
        # Try to select the new tag or fall back to the previous selection
        if new_tag_id or current_tag_id:
            target_tag_id = new_tag_id or current_tag_id
            found = False
            for s, sec in enumerate(self.sections):
                for i, item in enumerate(sec):
                    if item.tag_id == target_tag_id:
                        self.sec_idx = s
                        self.idx_in_sec = i
                        found = True
                        break
                if found:
                    break
            if not found:
                # Fall back to first item in first section
                if self.sections:
                    self.sec_idx = 0
                    self.idx_in_sec = 0
        self.updateSelection()

    def toggle_hidden(self):
        """Toggle visibility of hidden items and save state."""
        self.show_hidden = not self.show_hidden
        settings = QtCore.QSettings("xAI", "jdbrowser")
        settings.setValue("show_hidden", self.show_hidden)
        self._rebuild_ui()

    def _setup_shortcuts(self):
        self.setFocusPolicy(QtCore.Qt.FocusPolicy.StrongFocus)
        self.normal_shortcuts = [
            (QtCore.Qt.Key_Right, self.moveHoriz, 1),
            (QtCore.Qt.Key_L, self.moveHoriz, 1),
            (QtCore.Qt.Key_Left, self.moveHoriz, -1),
            (QtCore.Qt.Key_H, self.moveHoriz, -1),
            (QtCore.Qt.Key_Down, self.moveVert, 1),
            (QtCore.Qt.Key_J, self.moveVert, 1),
            (QtCore.Qt.Key_Up, self.moveVert, -1),
            (QtCore.Qt.Key_K, self.moveVert, -1),
            (QtCore.Qt.Key_BracketLeft, self.moveToSectionStart, None),
            (QtCore.Qt.Key_BracketRight, self.moveToSectionEnd, None),
            (QtCore.Qt.Key_G, self.moveToAbsoluteFirst, None),
            (QtCore.Qt.Key_G, self.moveToAbsoluteLast, None, QtCore.Qt.KeyboardModifier.ShiftModifier),
            (QtCore.Qt.Key_U, self.moveVertMultiple, -3, QtCore.Qt.KeyboardModifier.ControlModifier),
            (QtCore.Qt.Key_D, self.moveVertMultiple, 3, QtCore.Qt.KeyboardModifier.ControlModifier),
            (QtCore.Qt.Key_PageUp, self.moveVertMultiple, -3),
            (QtCore.Qt.Key_PageDown, self.moveVertMultiple, 3),
            (QtCore.Qt.Key_Z, self.centerSelectedItem, None),
            (QtCore.Qt.Key_Y, self.copySelectedName, None),
            (QtCore.Qt.Key_Slash, self.enter_search_mode, None),
            (QtCore.Qt.Key_F, self.enter_search_mode, None, QtCore.Qt.KeyboardModifier.ControlModifier),
            (QtCore.Qt.Key_0, self.firstInRow, None),
            (QtCore.Qt.Key_Dollar, self.lastInRow, None),
            (QtCore.Qt.Key_Home, self.firstInRow, None),
            (QtCore.Qt.Key_End, self.lastInRow, None),
            (QtCore.Qt.Key_H, self.toggle_hidden, None, QtCore.Qt.KeyboardModifier.ControlModifier),
            (QtCore.Qt.Key_A, self._append_tag_to_section, None),
            (QtCore.Qt.Key_I, self._input_tag_dialog, None),
            (QtCore.Qt.Key_C, self._edit_tag_label_with_icon, None),
            (QtCore.Qt.Key_R, self._rename_tag_label, None),
            (QtCore.Qt.Key_F2, self._rename_tag_label, None),
            (QtCore.Qt.Key_D, self._delete_tag, None),
            (QtCore.Qt.Key_T, self._set_thumbnail, None),
        ]
        quit_keys = ['Q', 'Ctrl+Q', 'Ctrl+W', 'Alt+F4']
        self.shortcuts = []
        for mapping in self.normal_shortcuts:
            key, func, arg = mapping[0], mapping[1], mapping[2]
            modifiers = mapping[3] if len(mapping) > 3 else QtCore.Qt.KeyboardModifier.NoModifier
            s = QtGui.QShortcut(QtGui.QKeySequence(key | modifiers), self)
            if arg is None:
                s.activated.connect(func)
            else:
                s.activated.connect(lambda f=func, a=arg: f(a))
            self.shortcuts.append(s)
        for seq in quit_keys:
            s = QtGui.QShortcut(QtGui.QKeySequence(seq), self)
            s.activated.connect(self.close)
            self.shortcuts.append(s)

    def enter_search_mode(self):
        if not self.in_search_mode:
            if not self.sections:
                return
            self.in_search_mode = True
            self.prev_sec_idx = self.sec_idx
            self.prev_idx_in_sec = self.idx_in_sec
            self.search_matches = []
            self.current_match_idx = -1
            self.search_input.clear()
            self.search_input.show()
            self.search_input.setFocus()
            for s in self.shortcuts:
                key_str = s.key().toString()
                if key_str and not any(key_str.lower() == seq.lower() for seq in ['Q', 'Ctrl+Q', 'Ctrl+W', 'Alt+F4']):
                    s.setEnabled(False)
            for s in self.search_shortcut_instances:
                s.setEnabled(True)
            self.perform_search("")

    def exit_search_mode_revert(self):
        if self.in_search_mode:
            self.in_search_mode = False
            self.search_input.hide()
            self.sec_idx = self.prev_sec_idx
            self.idx_in_sec = self.prev_idx_in_sec
            self.search_matches = []
            self.current_match_idx = -1
            for s in self.shortcuts:
                s.setEnabled(True)
            for s in self.search_shortcut_instances:
                s.setEnabled(False)
            for sec in self.sections:
                for item in sec:
                    item.isDimmed = False
                    item.updateStyle()
            self.updateSelection()

    def exit_search_mode_select(self):
        if self.in_search_mode:
            self.in_search_mode = False
            self.search_input.hide()
            if self.search_matches and self.current_match_idx >= 0:
                self.sec_idx, self.idx_in_sec = self.search_matches[self.current_match_idx]
            self.search_matches = []
            self.current_match_idx = -1
            for s in self.shortcuts:
                s.setEnabled(True)
            for s in self.search_shortcut_instances:
                s.setEnabled(False)
            for sec in self.sections:
                for item in sec:
                    item.isDimmed = False
                    item.updateStyle()
            self.updateSelection()

    def perform_search(self, query):
        if not self.sections:
            return
        query = query.lower()
        self.search_matches = []
        for s, sec in enumerate(self.sections):
            for i, item in enumerate(sec):
                if item.tag_id and query in item.display_name.lower():  # Skip placeholders
                    self.search_matches.append((s, i))
                item.isDimmed = query and (not item.tag_id or not query in item.display_name.lower())
                item.updateStyle()
        if self.search_matches:
            self.current_match_idx = 0
            self.sec_idx, self.idx_in_sec = self.search_matches[0]
        else:
            self.current_match_idx = -1
        self.updateSelection()

    def next_match(self):
        if self.in_search_mode and self.current_match_idx < len(self.search_matches) - 1:
            self.current_match_idx += 1
            self.sec_idx, self.idx_in_sec = self.search_matches[self.current_match_idx]
            self.updateSelection()

    def prev_match(self):
        if self.in_search_mode and self.current_match_idx > 0:
            self.current_match_idx -= 1
            self.sec_idx, self.idx_in_sec = self.search_matches[self.current_match_idx]
            self.updateSelection()

    def moveHoriz(self, delta):
        if not self.in_search_mode and self.sections:
            sec = self.sections[self.sec_idx]
            new = self.idx_in_sec + delta
            if 0 <= new < len(sec):
                self.idx_in_sec = new
                self.desired_col = self.idx_in_sec % self.cols
            self.updateSelection()

    def moveVert(self, direction):
        if not self.in_search_mode and self.sections:
            pref_col = self.desired_col
            sec_index = self.sec_idx
            idx = self.idx_in_sec
            cols = self.cols
            sec = self.sections[sec_index]
            row = idx // cols
            rows = (len(sec) + cols - 1) // cols
            if direction > 0:
                if row + 1 < rows:
                    r2 = row + 1
                    length = min(cols, len(sec) - r2 * cols)
                    self.idx_in_sec = r2 * cols + min(pref_col, length - 1)
                elif sec_index + 1 < len(self.sections):
                    sec2 = self.sections[sec_index + 1]
                    length = min(cols, len(sec2))
                    self.sec_idx += 1
                    self.idx_in_sec = min(pref_col, length - 1)
                self.updateSelection()
            else:
                if row > 0:
                    r2 = row - 1
                    length = min(cols, len(sec) - r2 * cols)
                    self.idx_in_sec = r2 * cols + min(pref_col, length - 1)
                elif sec_index > 0:
                    sec2 = self.sections[sec_index - 1]
                    rows2 = (len(sec2) + cols - 1) // cols
                    last = rows2 - 1
                    length = min(cols, len(sec2) - last * cols)
                    self.sec_idx -= 1
                    self.idx_in_sec = last * cols + min(pref_col, length - 1)
                self.updateSelection()

    def moveToSectionStart(self):
        if not self.in_search_mode and self.sections:
            if self.idx_in_sec == 0 and self.sec_idx > 0:
                self.sec_idx -= 1
                self.idx_in_sec = 0
            else:
                self.idx_in_sec = 0
            self.desired_col = 0
            self.updateSelection()

    def moveToSectionEnd(self):
        if not self.in_search_mode and self.sections:
            sec = self.sections[self.sec_idx]
            last_idx = len(sec) - 1
            if self.idx_in_sec == last_idx and self.sec_idx < len(self.sections) - 1:
                self.sec_idx += 1
                sec = self.sections[self.sec_idx]
                self.idx_in_sec = len(sec) - 1
            else:
                self.idx_in_sec = last_idx
            self.desired_col = self.idx_in_sec % self.cols
            self.updateSelection()

    def moveToAbsoluteFirst(self):
        if not self.in_search_mode and self.sections:
            self.sec_idx = 0
            self.idx_in_sec = 0
            self.desired_col = 0
            self.updateSelection()

    def moveToAbsoluteLast(self):
        if not self.in_search_mode and self.sections:
            self.sec_idx = len(self.sections) - 1
            sec = self.sections[self.sec_idx]
            self.idx_in_sec = len(sec) - 1
            self.desired_col = self.idx_in_sec % self.cols
            self.updateSelection()

    def moveVertMultiple(self, count):
        if not self.in_search_mode and self.sections:
            for _ in range(abs(count)):
                self.moveVert(1 if count > 0 else -1)

    def centerSelectedItem(self):
        if not self.in_search_mode and self.sections:
            current = self.sections[self.sec_idx][self.idx_in_sec]
            self.scroll.ensureWidgetVisible(current)
            viewport = self.scroll.viewport()
            viewport_height = viewport.height()
            widget_rect = current.rect()
            widget_pos = current.mapTo(self.scroll.widget(), widget_rect.topLeft())
            scroll_bar = self.scroll.verticalScrollBar()
            target_pos = widget_pos.y() - (viewport_height - widget_rect.height()) // 2
            scroll_bar.setValue(max(0, target_pos))
            self.updateSelection()

    def copySelectedName(self):
        if not self.in_search_mode and self.sections:
            current = self.sections[self.sec_idx][self.idx_in_sec]
            if current.tag_id:  # Skip placeholders
                clipboard = QtWidgets.QApplication.clipboard()
                clipboard.setText(current.display_name)

    def firstInRow(self):
        if not self.in_search_mode and self.sections:
            row = self.idx_in_sec // self.cols
            self.idx_in_sec = row * self.cols
            self.desired_col = 0
            self.updateSelection()

    def lastInRow(self):
        if not self.in_search_mode and self.sections:
            sec = self.sections[self.sec_idx]
            row = self.idx_in_sec // self.cols
            length = min(self.cols, len(sec) - row * self.cols)
            self.idx_in_sec = row * cols + length - 1
            self.desired_col = length - 1
            self.updateSelection()

    def updateSelection(self):
        if self.sections and 0 <= self.sec_idx < len(self.sections) and 0 <= self.idx_in_sec < len(self.sections[self.sec_idx]):
            current = self.sections[self.sec_idx][self.idx_in_sec]
            self.scroll.ensureWidgetVisible(current)
            for s, sec in enumerate(self.sections):
                for i, item in enumerate(sec):
                    item.isSelected = (s == self.sec_idx and i == self.idx_in_sec)
                    item.updateStyle()

    def mousePressEvent(self, event):
        if self.in_search_mode:
            self.exit_search_mode_select()
        super().mousePressEvent(event)

    def closeEvent(self, event):
        settings = QtCore.QSettings("xAI", "jdbrowser")
        settings.setValue("pos", self.pos())
        settings.setValue("size", self.size())
        self.conn.close()
        super().closeEvent(event)

    def keyPressEvent(self, event):
        super().keyPressEvent(event)

    def resizeEvent(self, event):
        self.search_input.move(self.width() - 310, self.height() - 40)
        # Update header widths on resize
        for widget in self.scroll.widget().findChildren(QtWidgets.QLabel):
            if widget.styleSheet().startswith(f'background-color: {BUTTON_COLOR}'):
                widget.setMinimumWidth(self.scroll.viewport().width() - 10)
        super().resizeEvent(event)

def read_config():
    config = configparser.ConfigParser()
    cfg_path = os.path.expanduser('~/.config/jdbrowser/config.conf')
    config.read(cfg_path)
    return config.get('settings', 'repository', fallback=os.getcwd())

if __name__ == '__main__':
    if len(sys.argv) > 1:
        directory = sys.argv[1]
    else:
        directory = read_config()
    directory = os.path.expanduser(directory)
    if not os.path.isdir(directory):
        print('Error:', directory, 'is not a valid directory.')
        sys.exit(1)

    app = QtWidgets.QApplication(sys.argv)
    app.setFont(QtGui.QFont('FiraCode Nerd Font'))
    browser = FileBrowser(directory)
    settings = QtCore.QSettings("xAI", "jdbrowser")
    if not (settings.contains("pos") and settings.contains("size")):
        browser.resize(1000, 600)
        screen = app.primaryScreen().geometry()
        browser.move((screen.width() - 1000) // 2, (screen.height() - 600) // 2)
    browser.show()
    timer = QtCore.QTimer()
    timer.timeout.connect(lambda: None)
    timer.start(100)
    sys.exit(app.exec())
