#!/home/jaguar/.pyenv/versions/jdbrowser/bin/python

import sys
import os
import configparser
import signal
from PySide6 import QtCore, QtGui, QtWidgets

# Allow Ctrl+C (SIGINT) to quit the Qt application
signal.signal(signal.SIGINT, lambda sig, frame: QtWidgets.QApplication.quit())

# Highlight colors
HIGHLIGHT_COLOR = '#44475a'
HOVER_COLOR = '#5c6370'
SLATE_COLOR = '#2e303e'

class FileItem(QtWidgets.QWidget):
    def __init__(self, name, parent_path):
        super().__init__()
        self.name = name
        self.isSelected = False
        self.isHover = False
        self.isDimmed = False
        self.setAttribute(QtCore.Qt.WidgetAttribute.WA_Hover)

        # Fix vertical size policy
        self.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)

        layout = QtWidgets.QVBoxLayout(self)
        layout.setSpacing(2)
        layout.setContentsMargins(2, 2, 2, 2)

        # Icon: Check if item is a folder and contains [00].png
        icon_path = os.path.join(parent_path, name, '[00].png')
        if os.path.isdir(os.path.join(parent_path, name)) and os.path.isfile(icon_path):
            self.icon = QtWidgets.QLabel()
            pixmap = QtGui.QPixmap(icon_path)
            if not pixmap.isNull():
                scaled_pixmap = pixmap.scaled(240, 150, QtCore.Qt.AspectRatioMode.KeepAspectRatio, QtCore.Qt.TransformationMode.SmoothTransformation)
                self.icon.setPixmap(scaled_pixmap)
                self.icon.setFixedSize(240, 150)
                self.icon.setStyleSheet('border-radius: 10px;')
            else:
                # Fallback to slate box if image is invalid
                self.icon = QtWidgets.QFrame()
                self.icon.setFixedSize(240, 150)
                self.icon.setStyleSheet(f'background-color: {SLATE_COLOR}; border-radius: 10px;')
        else:
            # Default slate box
            self.icon = QtWidgets.QFrame()
            self.icon.setFixedSize(240, 150)
            self.icon.setStyleSheet(f'background-color: {SLATE_COLOR}; border-radius: 10px;')
        self.icon.setAutoFillBackground(True)
        layout.addWidget(self.icon, alignment=QtCore.Qt.AlignmentFlag.AlignHCenter)

        # Label (single line)
        self.label = QtWidgets.QLabel(name)
        self.label.setAlignment(QtCore.Qt.AlignmentFlag.AlignHCenter)
        self.label.setFixedWidth(240)
        self.label.setWordWrap(False)
        self.label.setStyleSheet('color: #c0caf5;')
        self.label.setAutoFillBackground(True)
        layout.addWidget(self.label, alignment=QtCore.Qt.AlignmentFlag.AlignHCenter)

        # Fixed height: icon + single line label + spacings and margins
        fm = self.label.fontMetrics()
        label_height = fm.height()
        spacing = layout.spacing()
        margins = layout.contentsMargins()
        total_height = 150 + label_height + spacing + margins.top() + margins.bottom()
        self.setFixedHeight(total_height)

        self.updateStyle()

    def updateStyle(self):
        # Use a single background highlight
        if self.isHover:
            bg = HOVER_COLOR
        elif self.isSelected:
            bg = HIGHLIGHT_COLOR
        else:
            bg = 'transparent'
        # Apply dimming for non-matching items using QGraphicsOpacityEffect
        opacity = 0.4 if self.isDimmed else 1.0
        icon_effect = QtWidgets.QGraphicsOpacityEffect(self.icon)
        icon_effect.setOpacity(opacity)
        self.icon.setGraphicsEffect(icon_effect)
        label_effect = QtWidgets.QGraphicsOpacityEffect(self.label)
        label_effect.setOpacity(opacity)
        self.label.setGraphicsEffect(label_effect)
        icon_style = f'background-color: {SLATE_COLOR}; border-radius: 10px;' if isinstance(self.icon, QtWidgets.QFrame) else 'border-radius: 10px;'
        self.setStyleSheet(f'background-color: {bg}; border-radius: 10px;')
        self.icon.setStyleSheet(icon_style)
        self.label.setStyleSheet('color: #c0caf5;')

    def enterEvent(self, event):
        self.isHover = True
        self.updateStyle()
        self.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        super().enterEvent(event)

    def leaveEvent(self, event):
        self.isHover = False
        self.updateStyle()
        self.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.ArrowCursor))
        super().leaveEvent(event)

class SearchLineEdit(QtWidgets.QLineEdit):
    def __init__(self, parent):
        super().__init__(parent)
        self.parent_browser = parent

    def focusOutEvent(self, event):
        # Exit search mode like Enter when losing focus
        self.parent_browser.exit_search_mode_select()
        super().focusOutEvent(event)

class FileBrowser(QtWidgets.QMainWindow):
    def __init__(self, directory):
        super().__init__()
        self.directory = directory
        self.setWindowTitle(f"File Browser - {self.directory}")
        self.cols = 5
        self.sections = []
        self.sec_idx = 0
        self.idx_in_sec = 0
        self.desired_col = 0
        self.in_search_mode = False
        self.prev_sec_idx = 0
        self.prev_idx_in_sec = 0
        self.search_matches = []
        self.current_match_idx = -1
        self.shortcuts = []
        # Load show_hidden state from QSettings
        settings = QtCore.QSettings("xAI", "jdbrowser")
        self.show_hidden = settings.value("show_hidden", False, type=bool)

        # Disable window decorations
        self.setWindowFlags(QtCore.Qt.FramelessWindowHint)

        self._setup_ui()
        self._setup_shortcuts()
        self.updateSelection()

        # Restore saved position and size
        if settings.contains("pos") and settings.contains("size"):
            self.move(settings.value("pos", type=QtCore.QPoint))
            self.resize(settings.value("size", type=QtCore.QSize))

    def _is_hidden_item(self, name):
        """Check if an item should be hidden based on naming patterns."""
        if self.show_hidden:
            return False
        hidden_patterns = [
            '[00].png', '[00] #auto.png',
            '[.00].png', '[.00] #auto.png',
            '[+0000].png', '[+0000] #auto.png',
            '[0-META 0000-00-00 00.00.00].png', '[0-META 0000-00-00 00.00.00] #auto.png'
        ]
        return name.startswith('.') or name in hidden_patterns

    def _setup_ui(self):
        self.scroll = QtWidgets.QScrollArea()
        self.scroll.setWidgetResizable(True)
        container = QtWidgets.QWidget()
        mainLayout = QtWidgets.QVBoxLayout(container)
        mainLayout.setSpacing(10)
        mainLayout.setContentsMargins(5, 5, 5, 5)

        self.sections = []
        current_section = []
        grid = QtWidgets.QGridLayout()
        grid.setSpacing(5)
        row = col = 0

        entries = sorted(os.listdir(self.directory), key=lambda x: x.lower())
        for name in entries:
            if self._is_hidden_item(name):
                continue
            if name.lower().endswith('.2do'):
                # flush current section
                if current_section:
                    self.sections.append(current_section)
                    sectionWidget = QtWidgets.QWidget()
                    sectionWidget.setLayout(grid)
                    sectionWidget.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
                    mainLayout.addWidget(sectionWidget)
                    mainLayout.setAlignment(sectionWidget, QtCore.Qt.AlignmentFlag.AlignLeft)
                # header
                header_text = os.path.splitext(name)[0]
                header = QtWidgets.QLabel(header_text)
                header.setAlignment(QtCore.Qt.AlignmentFlag.AlignLeft | QtCore.Qt.AlignmentFlag.AlignVCenter)
                font = header.font()
                font.setPointSize(int(font.pointSize() * 1.5))
                font.setBold(True)
                header.setFont(font)
                header.setStyleSheet('background-color: #d7ba7d; color: black; padding-left:5px; padding-right:5px;')
                fm = header.fontMetrics()
                header.setFixedHeight(fm.height() + 6)
                mainLayout.addWidget(header)
                # reset for new section
                current_section = []
                grid = QtWidgets.QGridLayout()
                grid.setSpacing(5)
                row = col = 0
                continue
            # normal item
            item = FileItem(name, self.directory)
            current_section.append(item)
            grid.addWidget(item, row, col)
            col += 1
            if col >= self.cols:
                col = 0
                row += 1
        # flush last section
        if current_section:
            self.sections.append(current_section)
            sectionWidget = QtWidgets.QWidget()
            sectionWidget.setLayout(grid)
            sectionWidget.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
            mainLayout.addWidget(sectionWidget)
            mainLayout.setAlignment(sectionWidget, QtCore.Qt.AlignmentFlag.AlignLeft)

        container.setStyleSheet('background-color: #000000;')
        self.scroll.setWidget(container)
        self.setCentralWidget(self.scroll)

        # Search input box
        self.search_input = SearchLineEdit(self)
        self.search_input.setFixedWidth(300)
        self.search_input.setFixedHeight(30)
        self.search_input.setStyleSheet('''
            QLineEdit {
                background-color: #2e303e;
                color: #c0caf5;
                border: 1px solid #44475a;
                border-radius: 5px;
                padding: 5px;
                font-family: 'FiraCode Nerd Font';
            }
        ''')
        self.search_input.hide()
        self.search_input.textChanged.connect(self.perform_search)

        # Position search input in bottom-right
        self.search_input.move(self.width() - 310, self.height() - 40)

        style = '''
        * { font-family: 'FiraCode Nerd Font'; }
        QWidget { background-color: #000000; }
        QMainWindow { background-color: #000000; }
        QScrollArea { border: none; background-color: #000000; }
        QScrollBar:vertical {
            width: 8px;
            background: #000000;
        }
        QScrollBar::handle:vertical {
            background: #44475a;
            min-height: 20px;
            border-radius: 4px;
        }
        QScrollBar::add-line, QScrollBar::sub-line { height: 0; }
        QScrollBar::add-page, QScrollBar::sub-page { background: none; }
        '''
        self.setStyleSheet(style)

    def _rebuild_ui(self):
        """Rebuild the UI to reflect the current show_hidden state."""
        # Save current selection if possible
        current_name = None
        if self.sections and 0 <= self.sec_idx < len(self.sections) and 0 <= self.idx_in_sec < len(self.sections[self.sec_idx]):
            current_name = self.sections[self.sec_idx][self.idx_in_sec].name
        # Clear current layout
        self.scroll.takeWidget()
        # Rebuild UI
        self.sections = []
        self._setup_ui()
        # Restore selection if possible
        if current_name:
            for s, sec in enumerate(self.sections):
                for i, item in enumerate(sec):
                    if item.name == current_name:
                        self.sec_idx = s
                        self.idx_in_sec = i
                        break
                else:
                    continue
                break
        self.updateSelection()

    def toggle_hidden(self):
        """Toggle visibility of hidden items and save state."""
        self.show_hidden = not self.show_hidden
        settings = QtCore.QSettings("xAI", "jdbrowser")
        settings.setValue("show_hidden", self.show_hidden)
        self._rebuild_ui()

    def _setup_shortcuts(self):
        self.setFocusPolicy(QtCore.Qt.FocusPolicy.StrongFocus)
        # Normal mode navigation keys
        self.normal_shortcuts = [
            (QtCore.Qt.Key_Right, self.moveHoriz, 1),
            (QtCore.Qt.Key_L, self.moveHoriz, 1),
            (QtCore.Qt.Key_Left, self.moveHoriz, -1),
            (QtCore.Qt.Key_H, self.moveHoriz, -1),
            (QtCore.Qt.Key_Down, self.moveVert, 1),
            (QtCore.Qt.Key_J, self.moveVert, 1),
            (QtCore.Qt.Key_Up, self.moveVert, -1),
            (QtCore.Qt.Key_K, self.moveVert, -1),
            (QtCore.Qt.Key_BracketLeft, self.moveToSectionStart, None),
            (QtCore.Qt.Key_BracketRight, self.moveToSectionEnd, None),
            (QtCore.Qt.Key_G, self.moveToAbsoluteFirst, None),
            (QtCore.Qt.Key_G, self.moveToAbsoluteLast, None, QtCore.Qt.KeyboardModifier.ShiftModifier),
            (QtCore.Qt.Key_U, self.moveVertMultiple, -3, QtCore.Qt.KeyboardModifier.ControlModifier),
            (QtCore.Qt.Key_D, self.moveVertMultiple, 3, QtCore.Qt.KeyboardModifier.ControlModifier),
            (QtCore.Qt.Key_PageUp, self.moveVertMultiple, -3),
            (QtCore.Qt.Key_PageDown, self.moveVertMultiple, 3),
            (QtCore.Qt.Key_Z, self.centerSelectedItem, None),
            (QtCore.Qt.Key_Y, self.copySelectedName, None),
            (QtCore.Qt.Key_Slash, self.enter_search_mode, None),
            (QtCore.Qt.Key_F, self.enter_search_mode, None, QtCore.Qt.KeyboardModifier.ControlModifier),
            (QtCore.Qt.Key_0, self.firstInRow, None),
            (QtCore.Qt.Key_Dollar, self.lastInRow, None),
            (QtCore.Qt.Key_H, self.toggle_hidden, None, QtCore.Qt.KeyboardModifier.ControlModifier),
        ]
        # Quit keys (always active)
        quit_keys = ['Q', 'Ctrl+Q', 'Ctrl+W', 'Alt+F4']
        self.shortcuts = []
        for mapping in self.normal_shortcuts:
            key, func, arg = mapping[0], mapping[1], mapping[2]
            modifiers = mapping[3] if len(mapping) > 3 else QtCore.Qt.KeyboardModifier.NoModifier
            s = QtGui.QShortcut(QtGui.QKeySequence(key | modifiers), self)
            if arg is None:
                s.activated.connect(func)
            else:
                s.activated.connect(lambda f=func, a=arg: f(a))
            self.shortcuts.append(s)
        for seq in quit_keys:
            s = QtGui.QShortcut(QtGui.QKeySequence(seq), self)
            s.activated.connect(self.close)
            self.shortcuts.append(s)

        # Search mode shortcuts
        self.search_shortcuts = [
            (QtCore.Qt.Key_Escape, self.exit_search_mode_revert, None),
            (QtCore.Qt.Key_BracketLeft, self.exit_search_mode_revert, None, QtCore.Qt.KeyboardModifier.ControlModifier),
            (QtCore.Qt.Key_Return, self.exit_search_mode_select, None),
            (QtCore.Qt.Key_G, self.next_match, None, QtCore.Qt.KeyboardModifier.ControlModifier),
            (QtCore.Qt.Key_G, self.prev_match, None, QtCore.Qt.KeyboardModifier.ControlModifier | QtCore.Qt.KeyboardModifier.ShiftModifier),
            (QtCore.Qt.Key_N, self.next_match, None, QtCore.Qt.KeyboardModifier.ControlModifier),
            (QtCore.Qt.Key_P, self.prev_match, None, QtCore.Qt.KeyboardModifier.ControlModifier),
        ]
        self.search_shortcut_instances = []
        for mapping in self.search_shortcuts:
            key, func, arg = mapping[0], mapping[1], mapping[2]
            modifiers = mapping[3] if len(mapping) > 3 else QtCore.Qt.KeyboardModifier.NoModifier
            s = QtGui.QShortcut(QtGui.QKeySequence(key | modifiers), self.search_input)
            s.setEnabled(False)  # Disabled by default
            if arg is None:
                s.activated.connect(func)
            else:
                s.activated.connect(lambda f=func, a=arg: f(a))
            self.search_shortcut_instances.append(s)

    def enter_search_mode(self):
        if not self.in_search_mode:
            self.in_search_mode = True
            self.prev_sec_idx = self.sec_idx
            self.prev_idx_in_sec = self.idx_in_sec
            self.search_matches = []
            self.current_match_idx = -1
            self.search_input.clear()
            self.search_input.show()
            self.search_input.setFocus()
            # Disable normal shortcuts except quit keys
            for s in self.shortcuts:
                key_str = s.key().toString()
                if key_str and not any(key_str.lower() == seq.lower() for seq in ['Q', 'Ctrl+Q', 'Ctrl+W', 'Alt+F4']):
                    s.setEnabled(False)
            # Enable search shortcuts
            for s in self.search_shortcut_instances:
                s.setEnabled(True)
            self.perform_search("")

    def exit_search_mode_revert(self):
        if self.in_search_mode:
            self.in_search_mode = False
            self.search_input.hide()
            self.sec_idx = self.prev_sec_idx
            self.idx_in_sec = self.prev_idx_in_sec
            self.search_matches = []
            self.current_match_idx = -1
            # Re-enable normal shortcuts
            for s in self.shortcuts:
                s.setEnabled(True)
            # Disable search shortcuts
            for s in self.search_shortcut_instances:
                s.setEnabled(False)
            # Reset dimming
            for sec in self.sections:
                for item in sec:
                    item.isDimmed = False
                    item.updateStyle()
            self.updateSelection()

    def exit_search_mode_select(self):
        if self.in_search_mode:
            self.in_search_mode = False
            self.search_input.hide()
            # If there are matches, select the current match
            if self.search_matches and self.current_match_idx >= 0:
                self.sec_idx, self.idx_in_sec = self.search_matches[self.current_match_idx]
            self.search_matches = []
            self.current_match_idx = -1
            # Re-enable normal shortcuts
            for s in self.shortcuts:
                s.setEnabled(True)
            # Disable search shortcuts
            for s in self.search_shortcut_instances:
                s.setEnabled(False)
            # Reset dimming
            for sec in self.sections:
                for item in sec:
                    item.isDimmed = False
                    item.updateStyle()
            self.updateSelection()

    def perform_search(self, query):
        query = query.lower()
        self.search_matches = []
        for s, sec in enumerate(self.sections):
            for i, item in enumerate(sec):
                if query in item.name.lower():
                    self.search_matches.append((s, i))
                item.isDimmed = query and not query in item.name.lower()
                item.updateStyle()
        # Select first match if available
        if self.search_matches:
            self.current_match_idx = 0
            self.sec_idx, self.idx_in_sec = self.search_matches[0]
        else:
            self.current_match_idx = -1
        self.updateSelection()

    def next_match(self):
        if self.in_search_mode and self.current_match_idx < len(self.search_matches) - 1:
            self.current_match_idx += 1
            self.sec_idx, self.idx_in_sec = self.search_matches[self.current_match_idx]
            self.updateSelection()

    def prev_match(self):
        if self.in_search_mode and self.current_match_idx > 0:
            self.current_match_idx -= 1
            self.sec_idx, self.idx_in_sec = self.search_matches[self.current_match_idx]
            self.updateSelection()

    def moveHoriz(self, delta):
        if not self.in_search_mode:
            sec = self.sections[self.sec_idx]
            new = self.idx_in_sec + delta
            if 0 <= new < len(sec):
                self.idx_in_sec = new
                # update preferred column
                self.desired_col = self.idx_in_sec % self.cols
            self.updateSelection()

    def moveVert(self, direction):
        if not self.in_search_mode:
            pref_col = self.desired_col
            sec_index = self.sec_idx
            idx = self.idx_in_sec
            cols = self.cols
            # within section
            sec = self.sections[sec_index]
            row = idx // cols
            rows = (len(sec) + cols - 1) // cols
            if direction > 0:
                if row + 1 < rows:
                    r2 = row + 1
                    length = min(cols, len(sec) - r2 * cols)
                    self.idx_in_sec = r2 * cols + min(pref_col, length - 1)
                elif sec_index + 1 < len(self.sections):
                    sec2 = self.sections[sec_index + 1]
                    length = min(cols, len(sec2))
                    self.sec_idx += 1
                    self.idx_in_sec = min(pref_col, length - 1)
            else:
                if row > 0:
                    r2 = row - 1
                    length = min(cols, len(sec) - r2 * cols)
                    self.idx_in_sec = r2 * cols + min(pref_col, length - 1)
                elif sec_index > 0:
                    sec2 = self.sections[sec_index - 1]
                    rows2 = (len(sec2) + cols - 1) // cols
                    last = rows2 - 1
                    length = min(cols, len(sec2) - last * cols)
                    self.sec_idx -= 1
                    self.idx_in_sec = last * cols + min(pref_col, length - 1)
            self.updateSelection()

    def moveToSectionStart(self):
        if not self.in_search_mode:
            if self.idx_in_sec == 0 and self.sec_idx > 0:
                self.sec_idx -= 1
                self.idx_in_sec = 0
            else:
                self.idx_in_sec = 0
            self.desired_col = 0
            self.updateSelection()

    def moveToSectionEnd(self):
        if not self.in_search_mode:
            sec = self.sections[self.sec_idx]
            last_idx = len(sec) - 1
            if self.idx_in_sec == last_idx and self.sec_idx < len(self.sections) - 1:
                self.sec_idx += 1
                sec = self.sections[self.sec_idx]
                self.idx_in_sec = len(sec) - 1
            else:
                self.idx_in_sec = last_idx
            self.desired_col = self.idx_in_sec % self.cols
            self.updateSelection()

    def moveToAbsoluteFirst(self):
        if not self.in_search_mode:
            self.sec_idx = 0
            self.idx_in_sec = 0
            self.desired_col = 0
            self.updateSelection()

    def moveToAbsoluteLast(self):
        if not self.in_search_mode:
            self.sec_idx = len(self.sections) - 1
            sec = self.sections[self.sec_idx]
            self.idx_in_sec = len(sec) - 1
            self.desired_col = self.idx_in_sec % self.cols
            self.updateSelection()

    def moveVertMultiple(self, count):
        if not self.in_search_mode:
            for _ in range(abs(count)):
                self.moveVert(1 if count > 0 else -1)

    def centerSelectedItem(self):
        if not self.in_search_mode:
            current = self.sections[self.sec_idx][self.idx_in_sec]
            self.scroll.ensureWidgetVisible(current)
            # Calculate position to center the widget vertically
            viewport = self.scroll.viewport()
            viewport_height = viewport.height()
            widget_rect = current.rect()
            widget_pos = current.mapTo(self.scroll.widget(), widget_rect.topLeft())
            scroll_bar = self.scroll.verticalScrollBar()
            target_pos = widget_pos.y() - (viewport_height - widget_rect.height()) // 2
            scroll_bar.setValue(max(0, target_pos))
            self.updateSelection()

    def copySelectedName(self):
        if not self.in_search_mode:
            current = self.sections[self.sec_idx][self.idx_in_sec]
            clipboard = QtWidgets.QApplication.clipboard()
            clipboard.setText(current.name)

    def firstInRow(self):
        if not self.in_search_mode:
            row = self.idx_in_sec // self.cols
            self.idx_in_sec = row * self.cols
            self.desired_col = 0
            self.updateSelection()

    def lastInRow(self):
        if not self.in_search_mode:
            sec = self.sections[self.sec_idx]
            row = self.idx_in_sec // self.cols
            length = min(self.cols, len(sec) - row * self.cols)
            self.idx_in_sec = row * self.cols + length - 1
            self.desired_col = length - 1
            self.updateSelection()

    def updateSelection(self):
        # scroll to ensure visible
        if self.sections and 0 <= self.sec_idx < len(self.sections) and 0 <= self.idx_in_sec < len(self.sections[self.sec_idx]):
            current = self.sections[self.sec_idx][self.idx_in_sec]
            self.scroll.ensureWidgetVisible(current)
            # update flags
            for s, sec in enumerate(self.sections):
                for i, item in enumerate(sec):
                    item.isSelected = False
            if not current.isHover:
                current.isSelected = True
            for sec in self.sections:
                for item in sec:
                    item.updateStyle()

    def mousePressEvent(self, event):
        if self.in_search_mode:
            # Exit search mode and allow normal click behavior
            self.exit_search_mode_select()
        super().mousePressEvent(event)

    def closeEvent(self, event):
        # Save window position and size before closing
        settings = QtCore.QSettings("xAI", "jdbrowser")
        settings.setValue("pos", self.pos())
        settings.setValue("size", self.size())
        super().closeEvent(event)

    def keyPressEvent(self, event):
        super().keyPressEvent(event)

    def resizeEvent(self, event):
        # Update search input position on window resize
        self.search_input.move(self.width() - 310, self.height() - 40)
        super().resizeEvent(event)

def read_config():
    config = configparser.ConfigParser()
    cfg_path = os.path.expanduser('~/.config/jdbrowser/config.conf')
    config.read(cfg_path)
    return config.get('settings', 'repository', fallback=os.getcwd())

if __name__ == '__main__':
    if len(sys.argv) > 1:
        directory = sys.argv[1]
    else:
        directory = read_config()
    directory = os.path.expanduser(directory)
    if not os.path.isdir(directory):
        print('Error:', directory, 'is not a valid directory.')
        sys.exit(1)

    app = QtWidgets.QApplication(sys.argv)
    app.setFont(QtGui.QFont('FiraCode Nerd Font'))
    browser = FileBrowser(directory)
    # Only set default size and position if no saved settings exist
    settings = QtCore.QSettings("xAI", "jdbrowser")
    if not (settings.contains("pos") and settings.contains("size")):
        browser.resize(1000, 600)
        # Center the window on the screen as a fallback
        screen = app.primaryScreen().geometry()
        browser.move((screen.width() - 1000) // 2, (screen.height() - 600) // 2)
    # Always show the window
    browser.show()
    # Keep Qt loop responsive to SIGINT (Ctrl+C)
    timer = QtCore.QTimer()
    timer.timeout.connect(lambda: None)
    timer.start(100)
    sys.exit(app.exec())
